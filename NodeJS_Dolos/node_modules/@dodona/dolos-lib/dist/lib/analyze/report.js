"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Report = void 0;
const assert_1 = __importDefault(require("assert"));
const pair_1 = require("./pair");
const defaultMap_1 = require("../util/defaultMap");
const file_1 = require("../file/file");
const pairedOccurrence_1 = require("./pairedOccurrence");
const range_1 = require("../util/range");
const sharedFingerprint_1 = require("./sharedFingerprint");
const utils_1 = require("../util/utils");
class Report {
    constructor(options, files) {
        this.options = options;
        // collection of all shared fingerprints
        this.fingerprints = new Map();
        this.occurrences = [];
        this.results = new Map();
        this.semanticResults = [];
        this.fileSet = new Set(files);
    }
    addOccurrences(hash, ...parts) {
        (0, assert_1.default)(parts.length > 0);
        let fingerprint = this.fingerprints.get(hash);
        if (!fingerprint) {
            fingerprint = new sharedFingerprint_1.SharedFingerprint(hash, parts[0].side.data);
            this.fingerprints.set(hash, fingerprint);
        }
        fingerprint.addAll(parts);
    }
    /**
     * Finish the report and apply postprocessing steps.
     */
    finish() {
        (0, assert_1.default)(this.scored !== null, "this report is already finished");
        const sortfn = (0, utils_1.closestMatch)(this.options.sortBy, {
            "total overlap": (a, b) => b.overlap - a.overlap,
            "longest fragment": (a, b) => b.longest - a.longest,
            "similarity": (a, b) => b.similarity - a.similarity,
        });
        if (sortfn === null) {
            throw new Error(`${this.options.sortBy} is not a valid field to sort on`);
        }
        let ints = this.build();
        ints = ints.map(pair => {
            pair.removeSmallerThan(this.options.minFragmentLength);
            pair.squash();
            return pair;
        });
        ints = ints.filter(i => i.fragmentCount > 0);
        this.semanticResults = this.encodeSemanticResults(this.results);
        this.scored = ints.map(i => this.calculateScore(i));
        this.scored = this.scored.filter(s => s.similarity >= this.options.minSimilarity);
        this.scored.sort(sortfn);
        if (this.options.limitResults) {
            console.error(`Limiting to ${this.options.limitResults} results.`);
            this.scored = this.scored.slice(0, this.options.limitResults);
        }
        Object.freeze(this);
    }
    get scoredPairs() {
        if (this.scored) {
            return this.scored;
        }
        else {
            throw new Error("This report is not finished yet, " +
                "but scoredPairs() was called");
        }
    }
    sharedFingerprints() {
        return Array.of(...this.fingerprints.values());
    }
    /**
     * Combining all shared fingerprints and build pairs
     */
    build() {
        const pairs = new defaultMap_1.DefaultMap(() => new Map());
        let maxFiles;
        if (this.options.maxFingerprintCount != null) {
            maxFiles = this.options.maxFingerprintCount;
        }
        else if (this.options.maxFingerprintPercentage != null) {
            maxFiles = this.options.maxFingerprintPercentage * this.fileSet.size;
        }
        else {
            maxFiles = this.fileSet.size;
        }
        const filteredFingerprints = Array.of(...this.fingerprints.values())
            .filter(k => k.files().length <= maxFiles);
        // create pairs
        for (const fingerprint of filteredFingerprints) {
            const parts = fingerprint.parts().sort((a, b) => file_1.File.compare(a.file, b.file));
            for (let i = 0; i < parts.length; i += 1) {
                const first = parts[i];
                for (let j = i + 1; j < parts.length; j += 1) {
                    const second = parts[j];
                    if (first.file === second.file) {
                        // ignore pairedOccurrences within the same file (internal duplication)
                        continue;
                    }
                    let pair = pairs.get(first.file).get(second.file);
                    if (!pair) {
                        pair = new pair_1.Pair(first.file, second.file);
                        pairs.get(first.file).set(second.file, pair);
                    }
                    const match = new pairedOccurrence_1.PairedOccurrence(first.side, second.side, fingerprint);
                    pair.addPair(match);
                }
            }
        }
        // flatten nested map
        return Array.of(...pairs.values())
            .map(m => Array.of(...m.values()))
            .flat();
    }
    files() {
        return Array.of(...this.fileSet);
    }
    calculateScore(pair) {
        const fragments = pair.fragments();
        const leftCovered = range_1.Range.totalCovered(fragments.map(f => f.leftkgrams));
        const rightCovered = range_1.Range.totalCovered(fragments.map(f => f.rightkgrams));
        const leftTotal = pair.leftFile.kgrams.length;
        const rightTotal = pair.rightFile.kgrams.length;
        return {
            pair: pair,
            overlap: leftCovered + rightCovered,
            longest: pair.longestFragment(),
            similarity: (leftCovered + rightCovered) / (leftTotal + rightTotal),
            leftCovered,
            rightCovered
        };
    }
    encodeSemanticResults(results) {
        const encodedResults = [];
        for (const [id1, map] of results.entries()) {
            for (const [id2, nodestats] of map.entries()) {
                const filtered = nodestats
                    .filter(n => n.childrenTotal > this.options.semanticMatchLength);
                if (filtered.length === 0)
                    continue;
                for (const nodeStat of filtered) {
                    encodedResults.push({
                        left: id1,
                        right: id2,
                        childrenTotal: nodeStat.childrenTotal,
                        occurrences: [...nodeStat.occurrences],
                        ownNodes: nodeStat.ownNodes,
                        childrenMatch: nodeStat.childrenMatch.get(id2) || 0,
                    });
                }
            }
        }
        return encodedResults;
    }
}
exports.Report = Report;
//# sourceMappingURL=report.js.map