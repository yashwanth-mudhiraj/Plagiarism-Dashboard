import { TokenizedFile } from "../file/tokenizedFile";
import { Index } from "./index";
import { HashFilter } from "../hashing/hashFilter";
import { Region } from "../util/region";
import { Occurrence } from "./report";
export declare type NodeStats = {
    ownNodes: number[];
    matchedNodeAmount: Map<number, number>;
    childrenMatch: Map<number, number>;
    childrenTotal: number;
    depth: number;
    occurrences: Set<number>;
};
export declare type PairedSemanticGroups<T> = {
    rightMatch: T;
    leftMatch: T;
};
export declare type LeftOnlySemanticGroup<T> = {
    leftMatch: T;
    occurrences: number[];
};
export declare type RightOnlySemanticGroup<T> = {
    rightMatch: T;
    occurrences: number[];
};
export declare type UnpairedSemanticGroups<T> = LeftOnlySemanticGroup<T> | RightOnlySemanticGroup<T>;
export declare type Pairable = {
    occurrences: Set<number>;
};
export declare class SemanticAnalyzer {
    private index;
    constructor(index: Index);
    semanticAnalysis(tokenizedFiles: TokenizedFile[], hashFilter?: HashFilter): Promise<[Occurrence[][], Map<number, Map<number, NodeStats[]>>]>;
    private semanticAnalysisOneFile;
    private recurse;
    readonly PERCENTAGE_CHILDREN_MATCH_EXCLUSIVE = 0.9;
    readonly PERCENTAGE_CHILDREN_MATCH_INCLUSIVE = 0.8;
    readonly PERCENTAGE_OWNNODE_MATCH = 0.8;
    private doesLevelMatch;
    private astWithMatches;
    static getFullRange(file: TokenizedFile, match: {
        ownNodes: number[];
    }): Region;
    static readonly PAIRING_TOLERANCE = 0.7;
    static pairMatches<T extends Pairable>(fileLeft: TokenizedFile, fileRight: TokenizedFile, leftMatches: T[], rightMatches: T[], occurrenceGroups: number[][]): [PairedSemanticGroups<T>[], UnpairedSemanticGroups<T>[]];
}
//# sourceMappingURL=SemanticAnalyzer.d.ts.map