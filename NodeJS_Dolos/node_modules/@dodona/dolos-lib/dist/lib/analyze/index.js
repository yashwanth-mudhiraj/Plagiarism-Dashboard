"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Index = void 0;
const assert_1 = __importDefault(require("assert"));
const options_1 = require("../util/options");
const range_1 = require("../util/range");
const region_1 = require("../util/region");
const winnowFilter_1 = require("../hashing/winnowFilter");
const report_1 = require("./report");
const SemanticAnalyzer_1 = require("./SemanticAnalyzer");
class Index {
    /**
     * Creates a Index object with a given Tokenizer , an optional Options
     * object, and an optional HashFilter.
     *
     * If no HashFilter is given, a new WinnowFilter is created with values geven
     * by the Options (or the default Options).
     *
     * After creation, first add files to the index which can then be queried.
     *
     * @param tokenizer A tokenizer for the correct programming language
     * @param options An object with the current options.
     * @param hashFilter An optional HashFilter to hashing the hashes returned by
     * the rolling hashing function.
     */
    constructor(tokenizer, options = new options_1.Options(), hashFilter) {
        this.options = options;
        this.tokenizer = tokenizer;
        this.kgramLength = options.kgramLength;
        this.kgramsInWindow = options.kgramsInWindow;
        this.hashFilter =
            hashFilter
                ? hashFilter
                : new winnowFilter_1.WinnowFilter(this.kgramLength, this.kgramsInWindow, options.kgramData);
    }
    /**
     * Compare a list of files with each other and the files already stored in the
     * index. The compared files are also added to the index.
     *
     * @param files: the file objects which need to be compared to the index
     * and each other. The file hashes will be added to the index.
     * @param hashFilter: an optional HashFilter. By default the HashFilter of the
     * Index object will be used.
     * @return an Report object, which is a list of Pairs
     * (containing all the pairedOccurrences between two files).
     */
    async compareFiles(files, hashFilter = this.hashFilter) {
        const tokenizedFiles = files.map(f => this.tokenizer.tokenizeFile(f));
        return this.compareTokenizedFiles(tokenizedFiles, hashFilter);
    }
    /**
       * Same as {@link Index#compareFiles} but files are already tokenized
       * Compare a list of files with each other and the files already stored in the
       * index. The compared files are also added to the index.
       *
       * @param tokenizedFiles: the tokenized file objects which need to be compared to the index
       * and each other. The file hashes will be added to the index.
       * @param hashFilter: an optional HashFilter. By default the HashFilter of the
       * Index object will be used.
       * @return an Report object, which is a list of Pairs
       * (containing all the pairedOccurrences between two files).
       */
    async compareTokenizedFiles(tokenizedFiles, hashFilter = this.hashFilter) {
        const report = new report_1.Report(this.options, tokenizedFiles);
        const map = await this.createMatches(tokenizedFiles, hashFilter);
        for (const [hash, occurrences] of map.entries()) {
            report.addOccurrences(hash, ...occurrences);
        }
        if (this.options.semantic) {
            const semanticAnalyzer = new SemanticAnalyzer_1.SemanticAnalyzer(this);
            const [occurrences, result] = await semanticAnalyzer.semanticAnalysis(tokenizedFiles, hashFilter);
            report.occurrences = occurrences;
            report.results = result;
        }
        report.finish();
        return report;
    }
    async createMatches(tokenizedFiles, hashFilter = this.hashFilter) {
        const index = new Map();
        tokenizedFiles.forEach(t => t.kgrams.splice(0, t.kgrams.length));
        for (const file of tokenizedFiles) {
            let kgram = 0;
            for await (const { data, hash, start, stop } of hashFilter.fingerprints(file.ast)) {
                // add kgram to file
                file.kgrams.push(new range_1.Range(start, stop));
                // sanity check
                (0, assert_1.default)(region_1.Region.isInOrder(file.mapping[start], file.mapping[stop])
                    // If we end our kgram on a ')', the location of the opening token is used.
                    // However, the location of this token in the file might be before
                    // the location of the starting token of the kmer
                    // For example: the last token of every ast is ')', closing the program.
                    // The location of this token is always (0, 0), since the program root is the first token.
                    // In this way, the 'end' token is before any other token in the AST.
                    || file.ast[stop] === ")", `Invalid ordering:
             expected ${file.mapping[start]}
             to start be before the end of ${file.mapping[stop]}`);
                const location = region_1.Region.merge(file.mapping[start], file.mapping[stop]);
                const part = {
                    file,
                    side: { index: kgram, start, stop, data, location }
                };
                // look if the index already contains the given hashing
                const matches = index.get(hash);
                if (matches) {
                    // add our matching part to the index
                    matches.push(part);
                }
                else {
                    // if the hashing does not yet exist in the index, add it
                    index.set(hash, [part]);
                }
                kgram += 1;
            }
        }
        return index;
    }
    /**
     * Compare a file to the index. A map will be returned containing the filename
     * of the matching file, along with a list of matching position between the
     * two files.
     *
     * @param file The file to query
     * @param hashFilter An optional HashFilter. By default the HashFilter of the
     * Index object will be used.
     * @return report with the results of the comparison
     * contains the common hashes (occurrences) between two files.
     */
    async compareFile(file, hashFilter = this.hashFilter) {
        return this.compareFiles([file], hashFilter);
    }
}
exports.Index = Index;
//# sourceMappingURL=index.js.map