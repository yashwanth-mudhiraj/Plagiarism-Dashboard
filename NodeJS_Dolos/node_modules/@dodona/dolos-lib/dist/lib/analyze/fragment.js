"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fragment = void 0;
const assert_1 = __importDefault(require("assert"));
const region_1 = require("../util/region");
const range_1 = require("../util/range");
/**
 * A fragment is a collection of one or more consequent pairedOccurrences (kgrams).
 *
 * A fragment can be extended with a new PairedOccurence if its kgram indices in both
 * files are directly after that of the fragment.
 */
class Fragment {
    constructor(initial) {
        this.pairs = [initial];
        this.leftkgrams = new range_1.Range(initial.left.index);
        this.rightkgrams = new range_1.Range(initial.right.index);
        this.leftSelection = initial.left.location;
        this.rightSelection = initial.right.location;
        this.mergedStart = initial.left.start;
        this.mergedData = initial.left.data;
        this.mergedStop = initial.left.stop;
    }
    extendable(other) {
        return this.leftkgrams.to == other.left.index &&
            this.rightkgrams.to == other.right.index;
    }
    extendWith(other) {
        (0, assert_1.default)(this.extendable(other), "match does not extend this fragment");
        this.pairs.push(other);
        if (this.mergedData && other.left.data) {
            if (this.mergedStop < other.left.start) {
                for (let i = 0; i < (other.left.start - this.mergedStop - 1); i++) {
                    this.mergedData.push("?");
                }
                for (let i = 0; i < other.left.data.length; i++) {
                    this.mergedData.push(other.left.data[i]);
                }
            }
            else {
                for (let i = this.mergedStop - other.left.start + 1; i < other.left.data.length; i++) {
                    this.mergedData.push(other.left.data[i]);
                }
            }
        }
        this.mergedStop = other.left.stop;
        // Merge kgrams index range
        this.leftkgrams =
            range_1.Range.merge(this.leftkgrams, new range_1.Range(other.left.index));
        this.rightkgrams =
            range_1.Range.merge(this.rightkgrams, new range_1.Range(other.right.index));
        // Merge selection
        this.leftSelection = region_1.Region.merge(this.leftSelection, other.left.location);
        this.rightSelection = region_1.Region.merge(this.rightSelection, other.right.location);
    }
    extendWithFragment(other) {
        const otherFirst = other.pairs[0];
        (0, assert_1.default)(this.extendable(otherFirst));
        this.pairs = this.pairs.concat(other.pairs);
        if (this.mergedData && other.mergedData) {
            if (this.mergedStop < other.leftkgrams.from) {
                for (let i = 0; i < (other.mergedStart - this.mergedStop - 1); i++) {
                    this.mergedData.push("?");
                }
                for (let i = 0; i < other.mergedData.length; i++) {
                    this.mergedData.push(other.mergedData[i]);
                }
            }
            else {
                for (let i = this.mergedStop - other.leftkgrams.from + 1; i < other.mergedData.length; i++) {
                    this.mergedData.push(other.mergedData[i]);
                }
            }
        }
        this.mergedStop = other.mergedStop;
        // merge kgram ranges
        this.leftkgrams =
            range_1.Range.merge(this.leftkgrams, other.leftkgrams);
        this.rightkgrams =
            range_1.Range.merge(this.rightkgrams, other.rightkgrams);
        // merge selections
        this.leftSelection = region_1.Region.merge(this.leftSelection, other.leftSelection);
        this.rightSelection = region_1.Region.merge(this.rightSelection, other.rightSelection);
    }
}
exports.Fragment = Fragment;
//# sourceMappingURL=fragment.js.map