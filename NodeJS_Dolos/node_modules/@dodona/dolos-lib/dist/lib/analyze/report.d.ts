import { Pair } from "./pair";
import { TokenizedFile } from "../file/tokenizedFile";
import { ASTRegion } from "./pairedOccurrence";
import { Options } from "../util/options";
import { SharedFingerprint } from "./sharedFingerprint";
import { NodeStats } from "./SemanticAnalyzer";
declare type Hash = number;
export interface ScoredPairs {
    pair: Pair;
    overlap: number;
    longest: number;
    similarity: number;
    leftCovered: number;
    rightCovered: number;
}
export interface Occurrence {
    file: TokenizedFile;
    side: ASTRegion;
}
export interface SemanticResult {
    left: number;
    right: number;
    childrenTotal: number;
    ownNodes: Array<number>;
    childrenMatch: number;
}
export interface EncodedSemanticResult extends SemanticResult {
    occurrences: Array<number>;
}
export interface DecodedSemanticResult extends SemanticResult {
    occurrences: Set<number>;
}
export declare class Report {
    readonly options: Options;
    private scored?;
    private fingerprints;
    private readonly fileSet;
    occurrences: Occurrence[][];
    results: Map<number, Map<number, NodeStats[]>>;
    semanticResults: Array<EncodedSemanticResult>;
    constructor(options: Options, files: TokenizedFile[]);
    addOccurrences(hash: Hash, ...parts: Array<Occurrence>): void;
    /**
     * Finish the report and apply postprocessing steps.
     */
    finish(): void;
    get scoredPairs(): Array<ScoredPairs>;
    sharedFingerprints(): Array<SharedFingerprint>;
    /**
     * Combining all shared fingerprints and build pairs
     */
    private build;
    files(): TokenizedFile[];
    private calculateScore;
    private encodeSemanticResults;
}
export {};
//# sourceMappingURL=report.d.ts.map