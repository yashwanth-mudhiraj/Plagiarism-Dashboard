"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pair = void 0;
const range_1 = require("../util/range");
const fragment_1 = require("./fragment");
const identifiable_1 = __importDefault(require("../util/identifiable"));
/**
 * This class represents all the fragments between two files (i.e. the
 * pair of their hashes).
 */
class Pair extends identifiable_1.default {
    constructor(leftFile, rightFile) {
        super();
        this.leftFile = leftFile;
        this.rightFile = rightFile;
        this.fragmentStart = new Map();
        this.fragmentEnd = new Map();
    }
    get fragmentCount() {
        return this.fragmentStart.size;
    }
    /**
     * Creates an array of fragments in this pair, sorted by their
     * leftkgrams range.
     */
    fragments() {
        return Array.of(...this.fragmentStart.values())
            .sort((a, b) => range_1.Range.compare(a.leftkgrams, b.leftkgrams));
    }
    /**
     * Add a new paired occurrence to the pair.
     *
     * Tries to extend existing fragments, or creates a new fragment.
     */
    addPair(newPair) {
        const start = this.key(newPair.left.index, newPair.right.index);
        const end = this.key(newPair.left.index + 1, newPair.right.index + 1);
        let fragment = this.fragmentEnd.get(start);
        if (fragment) {
            // extend fragment at starting position
            this.fragmentEnd.delete(start);
            fragment.extendWith(newPair);
        }
        else {
            // no fragment on our starting position, create a new one
            fragment = new fragment_1.Fragment(newPair);
            this.fragmentStart.set(start, fragment);
            this.fragmentEnd.set(end, fragment);
        }
        const nextfragment = this.fragmentStart.get(end);
        if (nextfragment) {
            // there is a fragment directly after us we can extend
            // remove next fragment's start position
            this.fragmentStart.delete(end);
            // extend ourselves
            fragment.extendWithFragment(nextfragment);
            // overwrite the end position of the next fragment with ours
            this.fragmentEnd.set(this.key(nextfragment.leftkgrams.to, nextfragment.rightkgrams.to), fragment);
        }
        else {
            // no fragment after us, just set our end position
            this.fragmentEnd.set(end, fragment);
        }
    }
    /**
     * Calculate how much kgrams both files share. Each kgram is only counted once.
     */
    totalOverlapkgrams() {
        return range_1.Range.totalCovered(this.fragments().map(m => m.leftkgrams).sort(range_1.Range.compare));
    }
    /**
     * Returns the length (in kgrams) of the largest fragment in this pair.
     */
    longestFragment() {
        return Math.max(...this.fragments().map(f => f.pairs.length));
    }
    /**
     * Remove fragments which have fewer than the given minimum of pairedOccurrences.
     */
    removeSmallerThan(minimum) {
        this.fragments()
            .filter(f => f.pairs.length < minimum)
            .forEach(f => this.removefragment(f));
    }
    /**
     * Remove each Fragment that is contained in a bigger Fragment.
     */
    squash() {
        const kandidates = new Set();
        for (const match of this.fragments()) {
            const iter = kandidates.values();
            let next = iter.next();
            let removed = false;
            while (!next.done && !removed) {
                const kandidate = next.value;
                if (match.leftkgrams.from > kandidate.leftkgrams.to) {
                    kandidates.delete(kandidate);
                }
                else if (kandidate.leftkgrams.contains(match.leftkgrams) &&
                    kandidate.rightkgrams.contains(match.rightkgrams)) {
                    this.removefragment(match);
                    removed = true;
                }
                next = iter.next();
            }
            if (!removed) {
                kandidates.add(match);
            }
        }
    }
    removefragment(fragment) {
        this.fragmentStart.delete(this.key(fragment.leftkgrams.from, fragment.rightkgrams.from));
        this.fragmentEnd.delete(this.key(fragment.leftkgrams.to, fragment.rightkgrams.to));
    }
    key(left, right) {
        return `${left}|${right}`;
    }
}
exports.Pair = Pair;
//# sourceMappingURL=pair.js.map