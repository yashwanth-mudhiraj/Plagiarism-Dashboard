/**
 * Generates a rolling hashing object that can be used to create hashes of a
 * sliding window of values as defined by the Rabin-Karp string matching
 * algorithm.
 */
export declare class RollingHash {
    /**
     * The modulus used in the hash calculation.
     *
     * Since we want to be able to take the product of two hashes, the product of
     * two hashes, the modulus multiplied by itself should not have more than the
     * available amount of bits of precision.
     *
     * Javascript has 53-bit precision numbers (doubles) so we pick the largest
     * prime number with 26 bits.
     */
    readonly mod: number;
    /**
     * The base (or radix) used in the hash calculation.
     *
     * The hashes/numbers generated by TokenHash should already use as much
     * bits as possible because they share the same modulus.
     *
     * We have chosen for the largest prime with 22 bits.
     */
    readonly base: number;
    /**
     * The size of the window/length of this rolling hash.
     */
    readonly k: number;
    private readonly memory;
    private readonly maxBase;
    private i;
    private hash;
    /**
     * Creates and initializes a new RollingHash instance.
     *
     * @param k The size of the window/length of which the hashes are calculated.
     */
    constructor(k: number);
    /**
     * Calculates a new hashing based on the previous hashing, and the new token value
     *
     * @param token the next token value.
     */
    nextHash(token: number): number;
    /**
     * Modular exponentiation without overflowing.
     * Code based on the pseudocode at
     * https://en.wikipedia.org/wiki/Modular_exponentiation#Pseudocode
     *
     * @param base the base
     * @param exp the exponent
     * @param mod the modulus
     */
    private modPow;
}
//# sourceMappingURL=rollingHash.d.ts.map