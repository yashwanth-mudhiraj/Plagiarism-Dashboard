"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeTokenizer = void 0;
const tree_sitter_1 = __importDefault(require("tree-sitter"));
const region_1 = require("../util/region");
const tokenizer_1 = require("./tokenizer");
class CodeTokenizer extends tokenizer_1.Tokenizer {
    /**
     * Creates a new tokenizer of the given language. Will throw an error when the
     * given language is not supported. See Tokenizer.supportedLanguages for a
     * list of all supported languages.
     *
     * @param language The language to use for this tokenizer.
     */
    constructor(language) {
        super();
        if (!CodeTokenizer.isSupportedLanguage(language)) {
            CodeTokenizer.registerLanguage(language);
        }
        this.language = language;
        this.parser = new tree_sitter_1.default();
        let languageModule;
        if (language === "elm") {
            languageModule = require("@elm-tooling/tree-sitter-elm");
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            languageModule = require("tree-sitter-" + language);
        }
        this.parser.setLanguage(languageModule);
    }
    /**
     * Returns true if the grammar of the given language is supported.
     *
     * @param language The name of the language to check
     */
    static isSupportedLanguage(language) {
        return this.supportedLanguages.includes(language);
    }
    /**
     * Registers an additional language to Dolos. For this to work, the supporting
     * module of the name `tree-sitter-someLanguage` must first be installed
     * manually through yarn or npm.
     *
     * The function will throw an error when the supported module is not found.
     *
     * @param language The name of the language to register
     */
    static registerLanguage(language) {
        try {
            if (language === "elm") {
                require("@elm-tooling/tree-sitter-elm");
            }
            else {
                require("tree-sitter-" + language);
            }
        }
        catch (error) {
            throw new Error(`The module 'tree-sitter-${language}' could not be found. ` +
                "Try to install it using npm or yarn, but it may not be supported (yet).");
        }
        this.supportedLanguages.push(language);
    }
    /**
     * Runs the parser on a given string. Returns a stringified version of the
     * abstract syntax tree.
     *
     * @param text The text string to parse
     */
    tokenize(text) {
        const tree = this.parser.parse(text);
        return tree.rootNode.toString();
    }
    /**
     * Runs the parser on a given string. Returns an async iterator returning
     * tuples containing the stringified version of the token and the
     * corresponding position.
     *
     * @param text The text string to parse
     */
    *generateTokens(text) {
        const tree = this.parser.parse(text);
        yield* this.tokenizeNode(tree.rootNode);
    }
    *tokenizeNode(node) {
        const fullSpan = new region_1.Region(node.startPosition.row, node.startPosition.column, node.endPosition.row, node.endPosition.column);
        const location = region_1.Region.diff(fullSpan, ...this.getChildrenRegions(node))[0];
        yield this.newToken("(", location);
        // "(node.type child1 child2 ...)"
        yield this.newToken(node.type, location);
        for (const child of node.namedChildren) {
            yield* this.tokenizeNode(child);
        }
        yield this.newToken(")", location);
    }
    getChildrenRegions(node) {
        const nodeToRegion = (node) => new region_1.Region(node.startPosition.row, node.startPosition.column, node.endPosition.row, node.endPosition.column);
        const getChildrenRegion = (node) => node.children.reduce((list, child) => [...list, ...getChildrenRegion(child), nodeToRegion(node)], []);
        return node.children.map(getChildrenRegion).flat();
    }
}
exports.CodeTokenizer = CodeTokenizer;
CodeTokenizer.supportedLanguages = ["c", "c-sharp", "bash", "java", "javascript", "python", "elm"];
//# sourceMappingURL=codeTokenizer.js.map