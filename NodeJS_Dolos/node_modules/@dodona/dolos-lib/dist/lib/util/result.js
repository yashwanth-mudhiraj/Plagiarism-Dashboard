"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Result = void 0;
function isError(value) {
    return value instanceof Error;
}
/**
 * A class that represents the result of a computation that could have failed.
 * Its value is either a T or an Error.
 *
 */
class Result {
    constructor(value) {
        this.value = value;
    }
    static try(canFail) {
        try {
            return Result.ok(canFail());
        }
        catch (error) {
            return Result.error(error);
        }
    }
    static async settled(result) {
        if (result.isOk()) {
            return Result.ok(await result.ok());
        }
        else {
            return Result.error(await result.error());
        }
    }
    static async all(promises) {
        const successes = [];
        const failures = [];
        for await (const result of promises) {
            if (result.isOk()) {
                successes.push(result.ok());
            }
            else {
                failures.push(result.error());
            }
        }
        if (failures.length > 0) {
            return Result.error(new Error("There were a few errors: \n" +
                failures.map(e => e.toString()).join("\n")));
        }
        else {
            return Result.ok(successes);
        }
    }
    static async tryAwait(canFail) {
        try {
            return Result.ok(await canFail());
        }
        catch (err) {
            return Result.error(err);
        }
    }
    static ok(value) {
        return new Result(value);
    }
    static error(error) {
        return new Result(error);
    }
    isError() {
        return isError(this.value);
    }
    map(f) {
        if (isError(this.value)) {
            return Result.error(this.value);
        }
        else {
            return Result.ok(f(this.value));
        }
    }
    andThen(f) {
        if (isError(this.value)) {
            return Result.error(this.value);
        }
        else {
            return f(this.value);
        }
    }
    ok() {
        if (isError(this.value)) {
            throw this.value;
        }
        else {
            return this.value;
        }
    }
    okOr(alt) {
        if (isError(this.value)) {
            return alt;
        }
        else {
            return this.value;
        }
    }
    okOrElse(alt) {
        if (isError(this.value)) {
            return alt();
        }
        else {
            return this.value;
        }
    }
    isOk() {
        return !isError(this.value);
    }
    error() {
        if (isError(this.value)) {
            return this.value;
        }
        else {
            throw new Error(`Result was not an error: ${this}`);
        }
    }
    toString() {
        return `Result[${this.value}]`;
    }
}
exports.Result = Result;
//# sourceMappingURL=result.js.map